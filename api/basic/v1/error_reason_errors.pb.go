// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package v1

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

func IsUnknown(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_UNKNOWN.String() && e.Code == 410
}

func ErrorUnknown(format string, args ...interface{}) *errors.Error {
	return errors.New(410, ErrorReason_UNKNOWN.String(), fmt.Sprintf(format, args...))
}

func IsSerberUnavailable(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_SERBER_UNAVAILABLE.String() && e.Code == 411
}

func ErrorSerberUnavailable(format string, args ...interface{}) *errors.Error {
	return errors.New(411, ErrorReason_SERBER_UNAVAILABLE.String(), fmt.Sprintf(format, args...))
}

func IsRequestTooFast(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_REQUEST_TOO_FAST.String() && e.Code == 412
}

func ErrorRequestTooFast(format string, args ...interface{}) *errors.Error {
	return errors.New(412, ErrorReason_REQUEST_TOO_FAST.String(), fmt.Sprintf(format, args...))
}

func IsTimeOut(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_TIME_OUT.String() && e.Code == 413
}

func ErrorTimeOut(format string, args ...interface{}) *errors.Error {
	return errors.New(413, ErrorReason_TIME_OUT.String(), fmt.Sprintf(format, args...))
}

func IsAuthCodeInvalid(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorUserReason_AUTH_CODE_INVALID.String() && e.Code == 440
}

func ErrorAuthCodeInvalid(format string, args ...interface{}) *errors.Error {
	return errors.New(440, ErrorUserReason_AUTH_CODE_INVALID.String(), fmt.Sprintf(format, args...))
}

func IsBlackUser(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorUserReason_BLACK_USER.String() && e.Code == 441
}

func ErrorBlackUser(format string, args ...interface{}) *errors.Error {
	return errors.New(441, ErrorUserReason_BLACK_USER.String(), fmt.Sprintf(format, args...))
}

func IsClientidRejected(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorSocketReason_CLIENTID_REJECTED.String() && e.Code == 420
}

func ErrorClientidRejected(format string, args ...interface{}) *errors.Error {
	return errors.New(420, ErrorSocketReason_CLIENTID_REJECTED.String(), fmt.Sprintf(format, args...))
}

func IsUpgrade(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorSocketReason_UPGRADE.String() && e.Code == 421
}

func ErrorUpgrade(format string, args ...interface{}) *errors.Error {
	return errors.New(421, ErrorSocketReason_UPGRADE.String(), fmt.Sprintf(format, args...))
}

func IsLogined(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorSocketReason_LOGINED.String() && e.Code == 422
}

func ErrorLogined(format string, args ...interface{}) *errors.Error {
	return errors.New(422, ErrorSocketReason_LOGINED.String(), fmt.Sprintf(format, args...))
}

func IsSwithHost(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorSocketReason_SWITH_HOST.String() && e.Code == 423
}

func ErrorSwithHost(format string, args ...interface{}) *errors.Error {
	return errors.New(423, ErrorSocketReason_SWITH_HOST.String(), fmt.Sprintf(format, args...))
}

func IsBlackDevice(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorSocketReason_BLACK_DEVICE.String() && e.Code == 424
}

func ErrorBlackDevice(format string, args ...interface{}) *errors.Error {
	return errors.New(424, ErrorSocketReason_BLACK_DEVICE.String(), fmt.Sprintf(format, args...))
}

func IsTokenExpire(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorSocketReason_TOKEN_EXPIRE.String() && e.Code == 425
}

func ErrorTokenExpire(format string, args ...interface{}) *errors.Error {
	return errors.New(425, ErrorSocketReason_TOKEN_EXPIRE.String(), fmt.Sprintf(format, args...))
}

func IsNoDeviceOnline(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorDeviceReason_NO_DEVICE_ONLINE.String() && e.Code == 460
}

func ErrorNoDeviceOnline(format string, args ...interface{}) *errors.Error {
	return errors.New(460, ErrorDeviceReason_NO_DEVICE_ONLINE.String(), fmt.Sprintf(format, args...))
}

func IsDeviceNoPair(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorDeviceReason_DEVICE_NO_PAIR.String() && e.Code == 461
}

func ErrorDeviceNoPair(format string, args ...interface{}) *errors.Error {
	return errors.New(461, ErrorDeviceReason_DEVICE_NO_PAIR.String(), fmt.Sprintf(format, args...))
}

func IsSmsDayLimitExceed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorLimitReason_SMS_DAY_LIMIT_EXCEED.String() && e.Code == 470
}

func ErrorSmsDayLimitExceed(format string, args ...interface{}) *errors.Error {
	return errors.New(470, ErrorLimitReason_SMS_DAY_LIMIT_EXCEED.String(), fmt.Sprintf(format, args...))
}
